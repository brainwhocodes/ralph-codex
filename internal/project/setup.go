package project

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
)

// SetupOptions holds options for project setup
type SetupOptions struct {
	ProjectName string
	TemplateDir string
	WithGit     bool
	Verbose     bool
	Prompt      string // A description of the project to generate customized templates
	Init        bool   // If true, initialize in current directory instead of creating new one
}

// SetupResult holds result of project setup
type SetupResult struct {
	ProjectPath    string
	FilesCreated   []string
	GitInitialized bool
	Success        bool
}

// Setup creates a new Ralph-managed project
func Setup(opts SetupOptions) (*SetupResult, error) {
	var projectPath string

	if opts.Init {
		// Initialize in current directory
		wd, err := os.Getwd()
		if err != nil {
			return nil, fmt.Errorf("failed to get working directory: %w", err)
		}
		projectPath = wd
		// Don't error if directory exists when using Init mode
	} else {
		if opts.ProjectName == "" {
			return nil, fmt.Errorf("project name is required")
		}

		// Validate project name
		if err := validateProjectName(opts.ProjectName); err != nil {
			return nil, fmt.Errorf("invalid project name: %w", err)
		}

		// Create project directory - use absolute path or relative to cwd
		if strings.HasPrefix(opts.ProjectName, "/") || strings.HasPrefix(opts.ProjectName, "~") {
			projectPath = opts.ProjectName
		} else {
			wd, err := os.Getwd()
			if err != nil {
				return nil, fmt.Errorf("failed to get working directory: %w", err)
			}
			projectPath = filepath.Join(wd, opts.ProjectName)
		}

		// Check if directory exists (only when not in Init mode)
		if _, err := os.Stat(projectPath); err == nil {
			return nil, fmt.Errorf("directory already exists: %s", projectPath)
		}
	}

	result := &SetupResult{
		ProjectPath:  projectPath,
		FilesCreated: []string{},
		Success:      false,
	}

	// Create base directory structure
	dirs := []string{
		projectPath,
		filepath.Join(projectPath, "src"),
		filepath.Join(projectPath, "examples"),
		filepath.Join(projectPath, "specs"),
		filepath.Join(projectPath, "docs"),
		filepath.Join(projectPath, "docs", "generated"),
		filepath.Join(projectPath, "logs"),
	}

	for _, dir := range dirs {
		if err := os.MkdirAll(dir, 0755); err != nil {
			return nil, fmt.Errorf("failed to create directory %s: %w", dir, err)
		}
		if opts.Verbose {
			fmt.Printf("Created directory: %s\n", dir)
		}
	}

	// Track which files were generated by Codex (to skip in template generation)
	codexGeneratedFiles := make(map[string]bool)

	// If prompt is provided, generate customized PROMPT.md and @fix_plan.md using Codex
	if opts.Prompt != "" {
		if opts.Verbose {
			fmt.Println("Generating customized templates with Codex...")
		}
		if err := generateTemplatesWithCodex(projectPath, opts.Prompt); err != nil {
			return nil, fmt.Errorf("failed to generate templates with Codex: %w", err)
		}
		codexGeneratedFiles["PROMPT.md"] = true
		codexGeneratedFiles["@fix_plan.md"] = true
	}

	// Create template files (skip files that were generated by Codex)
	files, err := createTemplateFiles(projectPath, opts.TemplateDir, codexGeneratedFiles)
	if err != nil {
		return nil, fmt.Errorf("failed to create template files: %w", err)
	}
	result.FilesCreated = files

	// Initialize git repository if requested
	if opts.WithGit {
		if err := initGitRepo(projectPath); err != nil {
			return nil, fmt.Errorf("failed to initialize git: %w", err)
		}
		result.GitInitialized = true
		if opts.Verbose {
			fmt.Println("Initialized git repository")
		}
	}

	// Create README
	readmePath := filepath.Join(projectPath, "README.md")
	if err := createREADME(readmePath, opts.ProjectName); err != nil {
		return nil, fmt.Errorf("failed to create README: %w", err)
	}
	result.FilesCreated = append(result.FilesCreated, readmePath)

	result.Success = true
	return result, nil
}

// validateProjectName checks if project name is valid
func validateProjectName(name string) error {
	if name == "" {
		return fmt.Errorf("name cannot be empty")
	}

	// Check for invalid characters
	for _, c := range name {
		if c == '/' || c == '\\' || c == ':' || c == '*' || c == '?' ||
			c == '"' || c == '<' || c == '>' || c == '|' {
			return fmt.Errorf("name contains invalid character: %c", c)
		}
	}

	return nil
}

// generateTemplatesWithCodex uses Codex to generate customized PROMPT.md and @fix_plan.md
// Uses the unified RunCodexWithDirectStream helper
func generateTemplatesWithCodex(projectPath string, prompt string) error {
	codexPrompt := fmt.Sprintf(
		"Generate a PROMPT.md and @fix_plan.md for a project with this description: %s. Write the files directly.",
		prompt,
	)
	return RunCodexWithDirectStream(codexPrompt, projectPath)
}

// createTemplateFiles creates template files in project directory
// skipFiles is a map of filenames to skip (e.g., files generated by Codex)
func createTemplateFiles(projectPath, templateDir string, skipFiles map[string]bool) ([]string, error) {
	files := []string{}

	// Default template directory
	if templateDir == "" {
		templateDir = "~/.ralph/templates"
	}

	// Expand ~ to home directory
	if strings.HasPrefix(templateDir, "~/") {
		home, err := os.UserHomeDir()
		if err != nil {
			return nil, fmt.Errorf("failed to get home directory: %w", err)
		}
		templateDir = filepath.Join(home, templateDir[2:])
	}

	// Template files to create
	templates := map[string]string{
		"PROMPT.md":    defaultPromptTemplate(),
		"@fix_plan.md": defaultFixPlanTemplate(),
		"@AGENT.md":    defaultAgentTemplate(),
	}

	for filename, content := range templates {
		// Skip files that were generated by Codex
		if skipFiles != nil && skipFiles[filename] {
			continue
		}

		targetPath := filepath.Join(projectPath, filename)

		// Try to load from template directory first
		templatePath := filepath.Join(templateDir, filename)
		var fileContent string

		if _, err := os.Stat(templatePath); err == nil {
			data, err := os.ReadFile(templatePath)
			if err != nil {
				return nil, fmt.Errorf("failed to read template %s: %w", templatePath, err)
			}
			fileContent = string(data)
		} else {
			fileContent = content
		}

		if err := os.WriteFile(targetPath, []byte(fileContent), 0644); err != nil {
			return nil, fmt.Errorf("failed to write %s: %w", targetPath, err)
		}
		files = append(files, targetPath)
	}

	return files, nil
}

// initGitRepo initializes a git repository in the project directory
func initGitRepo(projectPath string) error {
	origDir, err := os.Getwd()
	if err != nil {
		return err
	}
	defer os.Chdir(origDir)

	if err := os.Chdir(projectPath); err != nil {
		return err
	}

	// Initialize git repo
	cmd := fmt.Sprintf("cd %s && git init", projectPath)
	if err := executeCommand(cmd); err != nil {
		return err
	}

	// Create .gitignore
	gitignorePath := filepath.Join(projectPath, ".gitignore")
	gitignoreContent := `# Ralph Codex
.ralph_session
.circuit_breaker_state
.exit_signals
.call_count
.response_analysis

# Logs
logs/

# OS
.DS_Store
Thumbs.db

# IDE
.vscode/
.idea/
*.swp
*.swo
`
	if err := os.WriteFile(gitignorePath, []byte(gitignoreContent), 0644); err != nil {
		return err
	}

	// Initial commit
	cmd = fmt.Sprintf("cd %s && git add . && git commit -m 'Initial commit from ralph-setup'", projectPath)
	if err := executeCommand(cmd); err != nil {
		return err
	}

	return nil
}

// createREADME creates a README.md for the project
func createREADME(path, projectName string) error {
	builder := &strings.Builder{}
	builder.WriteString("# " + projectName + "\n\n")
	builder.WriteString("This is a Ralph Codex managed project.\n\n")
	builder.WriteString("## Getting Started\n\n")
	builder.WriteString("Ralph Codex autonomously develops software based on specifications in:\n")
	builder.WriteString("- PROMPT.md - Main development instructions\n")
	builder.WriteString("- @fix_plan.md - Prioritized task list\n")
	builder.WriteString("- @AGENT.md - Build and run instructions\n\n")
	builder.WriteString("## Running Ralph\n\n")
	builder.WriteString("To start the autonomous development loop:\n\n")
	builder.WriteString("```bash\n")
	builder.WriteString("ralph\n")
	builder.WriteString("```\n\n")
	builder.WriteString("With monitoring dashboard:\n\n")
	builder.WriteString("```bash\n")
	builder.WriteString("ralph --monitor\n")
	builder.WriteString("```\n\n")
	builder.WriteString("## Project Structure\n\n")
	builder.WriteString("- src/ - Source code\n")
	builder.WriteString("- examples/ - Usage examples\n")
	builder.WriteString("- specs/ - Project specifications\n")
	builder.WriteString("- docs/ - Documentation\n")
	builder.WriteString("- logs/ - Ralph execution logs\n")
	builder.WriteString("- docs/generated/ - Auto-generated documentation\n\n")
	builder.WriteString("## Status\n\n")
	builder.WriteString("Ralph manages the development cycle. Check @fix_plan.md for current progress.\n")

	return os.WriteFile(path, []byte(builder.String()), 0644)
}

// CommandRunner defines the interface for executing shell commands
// This allows for easy mocking in tests
type CommandRunner interface {
	Run(command string) error
}

// DefaultCommandRunner executes commands using os/exec
type DefaultCommandRunner struct{}

// Run executes a shell command using sh -c
func (r *DefaultCommandRunner) Run(command string) error {
	cmd := exec.Command("sh", "-c", command)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	return cmd.Run()
}

// commandRunner is the current command runner, can be swapped for testing
var commandRunner CommandRunner = &DefaultCommandRunner{}

// SetCommandRunner sets a custom command runner (useful for testing)
func SetCommandRunner(r CommandRunner) {
	commandRunner = r
}

// ResetCommandRunner resets to the default command runner
func ResetCommandRunner() {
	commandRunner = &DefaultCommandRunner{}
}

// executeCommand executes a shell command using the current CommandRunner
func executeCommand(cmd string) error {
	return commandRunner.Run(cmd)
}

// ValidateProject checks if current directory is a valid Ralph project
// Delegates to the unified ValidateProjectDir function
func ValidateProject() error {
	return ValidateProjectDir(".")
}

// GetProjectRoot finds the project root directory
// Note: This is the setup.go version that is separate from mode.go's FindProjectRoot
// to avoid import cycles. Both have the same behavior.
func GetProjectRoot() (string, error) {
	root, _, err := FindProjectRoot("")
	return root, err
}

// defaultPromptTemplate returns default PROMPT.md content
func defaultPromptTemplate() string {
	builder := &strings.Builder{}
	builder.WriteString("# Ralph Codex Development Instructions\n\n")
	builder.WriteString("You are an autonomous AI developer working on this project.\n\n")
	builder.WriteString("## Project Goals\n\n")
	builder.WriteString("[Describe what this project should accomplish]\n\n")
	builder.WriteString("## Development Rules\n\n")
	builder.WriteString("1. Always read the plan file (@fix_plan.md, IMPLEMENTATION_PLAN.md, or REFACTOR_PLAN.md) before starting work\n")
	builder.WriteString("2. Follow @AGENT.md for build and run instructions\n")
	builder.WriteString("3. Run tests after each change\n")
	builder.WriteString("4. Commit your work regularly with clear messages\n")
	builder.WriteString("5. **UPDATE THE PLAN FILE** when you complete a task - change `- [ ]` to `- [x]`\n")
	builder.WriteString("6. **IMPORTANT**: Always output a RALPH_STATUS block at the end of your response\n\n")
	builder.WriteString("## Task Completion Workflow\n\n")
	builder.WriteString("When you complete a task:\n")
	builder.WriteString("1. Edit the plan file to mark the task complete: `- [ ] Task` â†’ `- [x] Task`\n")
	builder.WriteString("2. Run tests to verify your changes\n")
	builder.WriteString("3. Commit your changes\n")
	builder.WriteString("4. Output RALPH_STATUS with accurate TASKS_COMPLETED_THIS_LOOP count\n")
	builder.WriteString("5. If ALL tasks are now marked [x], set EXIT_SIGNAL: true\n\n")
	builder.WriteString("## Tech Stack\n\n")
	builder.WriteString("[List your technologies here]\n\n")
	builder.WriteString("## Status Reporting (REQUIRED)\n\n")
	builder.WriteString("You MUST end every response with a RALPH_STATUS block. This tells Ralph whether to continue or stop.\n\n")
	builder.WriteString("```\n")
	builder.WriteString("---RALPH_STATUS---\n")
	builder.WriteString("STATUS: WORKING | COMPLETE | BLOCKED\n")
	builder.WriteString("TASKS_COMPLETED_THIS_LOOP: <number>\n")
	builder.WriteString("FILES_MODIFIED: <number>\n")
	builder.WriteString("TESTS_STATUS: PASSING | FAILING | UNKNOWN\n")
	builder.WriteString("WORK_TYPE: feature | bugfix | test | docs | refactor\n")
	builder.WriteString("EXIT_SIGNAL: true | false\n")
	builder.WriteString("RECOMMENDATION: <brief next step or 'none'>\n")
	builder.WriteString("---END_RALPH_STATUS---\n")
	builder.WriteString("```\n\n")
	builder.WriteString("### When to set EXIT_SIGNAL: true\n\n")
	builder.WriteString("- All tasks in @fix_plan.md are marked [x] complete\n")
	builder.WriteString("- You've verified tests pass\n")
	builder.WriteString("- There's nothing more to do\n")
	builder.WriteString("- You're blocked and cannot proceed without human input\n\n")
	builder.WriteString("### When to set EXIT_SIGNAL: false\n\n")
	builder.WriteString("- There are still uncompleted tasks\n")
	builder.WriteString("- Tests are failing and need fixes\n")
	builder.WriteString("- You made progress but more work remains\n")
	return builder.String()
}

// defaultFixPlanTemplate returns default @fix_plan.md content
func defaultFixPlanTemplate() string {
	builder := &strings.Builder{}
	builder.WriteString("# Ralph Development Task List\n\n")
	builder.WriteString("**IMPORTANT**: Mark tasks complete by changing `- [ ]` to `- [x]` as you finish them.\n")
	builder.WriteString("When ALL tasks are marked [x], set EXIT_SIGNAL: true in your RALPH_STATUS block.\n\n")
	builder.WriteString("## Phase 1: Initial Setup\n")
	builder.WriteString("- [ ] Create project structure\n")
	builder.WriteString("- [ ] Set up development environment\n")
	builder.WriteString("- [ ] Write initial tests\n")
	builder.WriteString("- [ ] Implement core features\n\n")
	builder.WriteString("## Phase 2: Development\n")
	builder.WriteString("- [ ] Implement feature X\n")
	builder.WriteString("- [ ] Implement feature Y\n")
	builder.WriteString("- [ ] Write tests for X and Y\n\n")
	builder.WriteString("## Phase 3: Polish\n")
	builder.WriteString("- [ ] Add documentation\n")
	builder.WriteString("- [ ] Performance optimization\n")
	builder.WriteString("- [ ] Code review and cleanup\n\n")
	builder.WriteString("## Phase 4: Deployment\n")
	builder.WriteString("- [ ] Prepare for release\n")
	builder.WriteString("- [ ] Deploy to production\n")
	return builder.String()
}

// defaultAgentTemplate returns default @AGENT.md content
func defaultAgentTemplate() string {
	builder := &strings.Builder{}
	builder.WriteString("# Build and Run Instructions\n\n")
	builder.WriteString("## Building the Project\n\n")
	builder.WriteString("```bash\n")
	builder.WriteString("go build ./...\n")
	builder.WriteString("```\n\n")
	builder.WriteString("## Running Tests\n\n")
	builder.WriteString("```bash\n")
	builder.WriteString("go test ./...\n")
	builder.WriteString("```\n\n")
	builder.WriteString("## Running the Application\n\n")
	builder.WriteString("```bash\n")
	builder.WriteString("./<binary-name>\n")
	builder.WriteString("```\n\n")
	builder.WriteString("## Development Workflow\n\n")
	builder.WriteString("1. Make changes to source code\n")
	builder.WriteString("2. Run tests to verify\n")
	builder.WriteString("3. Build the project\n")
	builder.WriteString("4. Update @fix_plan.md (mark completed tasks with [x])\n")
	builder.WriteString("5. Commit changes\n")
	builder.WriteString("6. **Output RALPH_STATUS block** (see PROMPT.md for format)\n\n")
	builder.WriteString("## Completion Checklist\n\n")
	builder.WriteString("Before setting EXIT_SIGNAL: true, verify:\n")
	builder.WriteString("- [ ] All tasks in @fix_plan.md are marked [x]\n")
	builder.WriteString("- [ ] All tests pass\n")
	builder.WriteString("- [ ] Code builds without errors\n")
	builder.WriteString("- [ ] Changes are committed\n")
	return builder.String()
}
